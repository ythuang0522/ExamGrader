{
  "1": {
    "text": "Suppose you are asked to implement the n-th Fibanacci number using recursion only (i.e., no loop implementation). How to avoid stack overflow for large n? Briefly explain your solution.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 關鍵概念辨識 (4 分)  \n  - 完全：正確指出使用傳統遞迴計算 Fibonacci 數時，過多且重複的遞迴呼叫可能導致堆疊溢位的問題。  \n  - 部分：僅提及遞迴可能遇到問題，但未明確點出堆疊溢位的因果關係。  \n  - 無得分：未提及或完全忽略堆疊溢位問題。\n\n- 解決方案描述 (4 分)  \n  - 完全：清楚提出使用尾端遞迴（tail recursion）或類似的優化策略，例如利用累積參數將遞迴改寫為類似迴圈的結構，以便編譯器進行尾端呼叫優化，從而有效避免堆疊溢位。  \n  - 部分：提及使用優化技術如尾端遞迴，但未說明如何利用累積參數或未闡述機制細節。  \n  - 無得分：僅泛泛而談無具體解決方法，或提出與題意無關方法。\n\n- 實作合理性與效能論述 (2 分)  \n  - 完全：說明所提策略可處理大數值 n 的情況，具體論述如何藉由降低堆疊深度來避免溢位，並闡明該方法的效能優勢。  \n  - 部分：簡單提及方案可用於大 n，但解釋不夠清楚或缺乏效能考量。  \n  - 無得分：完全未提及或論述不符合大 n 情境下避免堆疊溢位的合理性。"
  },
  "2": {
    "text": "What is the Big O complexity of following recurrence? Justify your answer.",
    "tables": [],
    "figures": [],
    "score": "20",
    "rubric": "- 正確判斷 Big O 複雜度 (8 分)  \n  - 全分：答案中明確且正確地指出遞迴的 Big O 複雜度，數值及量級完全正確。  \n  - 部分分：答案指出的複雜度較接近正確，但存在細節或數值上的輕微誤差，或缺乏必要的說明。  \n  - 不給分：未能正確判斷出正確的 Big O 複雜度，或答案完全不符合題意。\n\n- 合理且詳細的證明與解釋 (10 分)  \n  - 全分：解釋中清楚描述所使用的方法（如主定理、遞迴樹、代入法等），並提供完整推導步驟與理論支持，邏輯嚴密。  \n  - 部分分：證明與解釋過程中提及部分正確方法，但步驟不夠完整或部分推導存在模糊、不夠清晰的地方。  \n  - 不給分：未提供合理的證明或解釋，或使用的方法與推導完全錯誤。\n\n- 筆記條理清晰與專業術語正確運用 (2 分)  \n  - 全分：答案邏輯清楚、步驟分明，專業術語的使用正確且得當。  \n  - 部分分：答案整體可理解，但存在部分邏輯不夠清晰或術語使用不當的情況。  \n  - 不給分：筆記混亂，缺乏必要的步驟說明，專業術語使用錯誤，導致難以理解。"
  },
  "2a": {
    "text": "T(n) = 2T(n/3) + cn, where c is a constant.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 主定理參數的正確識別與應用 (3 分)  \n  - 完全得分：明確指出遞迴式為 T(n)=2T(n/3)+cn，正確設定參數 a=2、b=3，並計算出 n^(log₃2)；  \n  - 部分得分：能識別出遞迴形式與參數，但 n^(log₃2) 計算不精確或描述不完整；  \n  - 無得分：未能正確設定主要參數或完全忽略主定理之應用。\n\n- f(n) 與子問題成本比較及正則性檢查 (3 分)  \n  - 完全得分：清楚比較 f(n)=cn 與 n^(log₃2) 的漸進增長，指出 cn 多項式上大於 n^(log₃2) 並說明正則性條件成立；  \n  - 部分得分：有進行比較但關鍵論點（例如多項式相差的程度或正則性檢查）闡述不夠詳盡；  \n  - 無得分：未能正確比較或忽略正則性條件之檢查。\n\n- 漸近解推導與結論陳述 (4 分)  \n  - 完全得分：正確推導得出 T(n)=Θ(n) 的最終解，並提供清晰合理的解釋和論證；  \n  - 部分得分：結論部分正確，但推導過程或解釋不夠完整或存在輕微錯誤；  \n  - 無得分：最終結論錯誤或缺乏必要的推導與解釋。"
  },
  "2b": {
    "text": "T(n) = 2T(\\sqrt{n}) + \\lg n (hint: you may replace n with other form)",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 變數替換與遞迴式轉換 (3 pts)  \n  - 完全得分：正確運用變數替換（如令 n = 2^m）並將原式 T(n) = 2T(√n) + lg n 轉換為等價的形式（例如 S(m) = 2S(m/2) + m）。  \n  - 部分得分：嘗試替換但轉換過程中有少數不嚴謹或符號誤用。  \n  - 無得分：未嘗試或完全錯誤的變數替換與轉換。\n\n- 遞迴式求解與複雜度推導 (5 pts)  \n  - 完全得分：正確求解轉換後的遞迴式，能運用主定理、遞迴樹法或其它方法推導出最終的時間複雜度（Θ(lg n · lg (lg n))）。  \n  - 部分得分：部分正確推導但最終答案或論證中存在明顯錯誤或不完整。  \n  - 無得分：未能正確求解遞迴式或全盤推導錯誤。\n\n- 論述過程與步驟解釋 (2 pts)  \n  - 完全得分：全程對每個步驟提供清晰解釋與論證，說明每個變數替換、遞迴關係推導及驗證過程。  \n  - 部分得分：部分步驟有合理說明，但部分關鍵步驟未做解釋或論證不夠詳盡。  \n  - 無得分：未提供必要的論述過程與步驟說明。"
  },
  "3": {
    "text": "Prove that an n-element heap has at most \\lceil n/2^{h+1} \\rceil nodes at height h.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 正確識別題目關鍵概念與前提（例如：堆的完整二元樹結構、節點高度的定義以及每層節點數量的基礎性質）（3 分）\n- 正確推導並論證節點數量上界，即利用數學推理（如歸納法、層次分析或指數性遞減的概念）證明 n-element 堆在高度 h 的節點數最多為 ⌈n/2^(h+1)⌉（4 分）\n- 論證過程邏輯清晰、結論明確且嚴謹，證明中的每個步驟都能有效銜接且無重大漏洞或遺漏（3 分）"
  },
  "4": {
    "text": "The radix sort can achieve time complexity better than all the comparison-based sorting algorithms (e.g., merge sort, quick sort). Why do all the programming languages still implement comparison-based sorting algorithms as the build-in function (e.g., qsort in C)?",
    "tables": [],
    "figures": [],
    "score": "5",
    "rubric": "- 關鍵概念識別與論述 (2 分)：  \n  完整回答需指出基數排序雖理論上時間複雜度較低，但此效能依賴特定資料條件（如固定長度、特殊格式或額外空間需求），因此僅適用於部分情境。  \n  • 完全提及上述關鍵點，得 2 分。  \n  • 僅提及部分條件或模糊描述，得 1 分。  \n  • 未提及或答非重點，得 0 分。\n\n- 比較型排序成為內建函式的理由 (2 分)：  \n  回答應強調比較型排序在通用性方面的優勢，包括對各種資料類型的適用性、較低的額外資源要求以及穩定且良好的平均效能。  \n  • 若論述充分且涵蓋這些點，得 2 分。  \n  • 若只提及其中一至兩點，得 1 分。  \n  • 未提及或論述錯誤，得 0 分。\n\n- 條理與論證的完整性及清晰度 (1 分)：  \n  回答需邏輯清楚、結構完整，能有機結合各論點。  \n  • 條理分明、表述清晰，得 1 分。  \n  • 表述混亂或結構欠缺，得 0 分。"
  },
  "5": {
    "text": "Consider a stick of length m meters that has to be cut at s_1, s_2, ..., s_n meters from left end, where m and s_i are all integers and the cut order of s_i can be any permutation. The cost of each cut s_i is the length of stick prior to the cut, and thus different permutation of cut order leads to different cost. Illustrate a dynamic programming algorithm for finding the minimum cut cost of a stick of length 30, which will be cut at 3, 6, 12, 17, 22, and 28 meters from left end. You should write down the recurrence, bottom-up DP computation, and backtrack one optimal solution.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 正確描述遞迴式與基礎條件 (3 分)：  \n  - 完全回答者必須寫出正確的遞迴關係（包含切分成本的公式，以及如何處理邊界條件）並清楚解釋其推導過程。  \n  - 若遞迴式正確但說明不夠完整或有小部分誤差，給予部分分；若完全缺乏正確遞迴式及解釋，則不得分。\n\n- 完整呈現自底向上 DP 計算過程 (4 分)：  \n  - 完全回答者需以表格或步驟形式清楚列出各子問題的計算順序，展示如何從最小子問題逐步求得整體問題的最小成本。  \n  - 若計算過程中有步驟缺漏、計算錯誤或表達不清，應依錯誤程度給予部分分；完全缺失此部分則不得分。\n\n- 正確回溯並呈現一個最佳切割順序 (3 分)：  \n  - 完全回答者必須利用 DP 表格正確回溯，並清楚指出一個能達到最小成本的切割順序，同時附上必要的說明。  \n  - 若回溯過程僅部分正確或敘述不完整，則給予部分分；完全缺失回溯或解答結果錯誤，則不得分。"
  },
  "6": {
    "text": "Longest common subsequence.",
    "tables": [],
    "figures": [],
    "score": "25",
    "rubric": "- 基本概念與問題描述 (5 分)\n  - 全滿分：完整正確地定義「最長公共子序列」概念，說明問題要求、輸入／輸出及邊界情形，並清楚區分子序列與子字串。\n  - 部分分：能提及 LCS 概念，但部分說明不夠完整或細節欠缺，對基本定義描述模糊。\n  - 無分：未能正確描述問題概念或描述與題意脫節。\n  \n- 動態規劃遞迴關係與狀態轉移設計 (10 分)\n  - 全滿分：正確推導出遞迴公式與動態規劃狀態轉移（例如：若兩字符相同則 dp[i][j] = dp[i-1][j-1] + 1，否則 dp[i][j] = max(dp[i-1][j], dp[i][j-1]）），並附合理解釋。\n  - 部分分：大致推導出遞迴關係，但解釋不夠詳盡或存在輕微邏輯錯誤，導致部分案例無法正確運作。\n  - 無分：未能呈現正確的遞迴公式或狀態轉移關係，概念錯誤或漏洞百出。\n  \n- 程式碼實作與複雜度分析 (10 分)\n  - 全滿分：提供完整正確的程式碼解法（包含初始化、狀態填表與回溯等步驟），妥善處理所有邊界情形，並清楚分析演算法的時間與空間複雜度。\n  - 部分分：程式碼部分正確，但存在邏輯錯誤或未完整處理某些邊界情形，複雜度分析較為簡略或部分不清楚。\n  - 無分：程式碼無法正確運行或與題意不符，缺乏有效的複雜度分析。"
  },
  "6a": {
    "text": "Write the optimal substructure (recurrence) of computing LCS of k sequences, where k = 3",
    "tables": [],
    "figures": [],
    "score": "5",
    "rubric": "- 正確表示匹配情況的遞迴關係：當三個序列当前字符相同 (例如 a[i]=b[j]=c[k]) 時，正確表達 LCS[i,j,k] = 1 + LCS[i-1, j-1, k-1]。（2 分；若條件或索引更新部分有誤或不完整則給部分分數）\n- 正確表示不匹配情況的遞迴關係：當至少一個字符不匹配時，正確表達 LCS[i,j,k] = max(LCS[i-1, j, k], LCS[i, j-1, k], LCS[i, j, k-1])。（2 分；若漏掉部分子問題或運算有誤則給部分分數）\n- 清楚定義變數與說明遞迴的最優子結構概念：包含必要的索引定義與邊界條件（例如初始值設定或說明遞迴邏輯）。（1 分；說明不完整或缺失則扣分）"
  },
  "6b": {
    "text": "Given a string, find the longest subsequence occurring at least twice in the string, requiring their indices must not overlap. e.g., Given ATATAGAGGC, the answer is 4 since ATAG occurs twice and their indices (i.e., (1,2,5,6) and (3,4,7,8)) do not overlap. Describe a dynamic programming (recurrence) for the string ATTAATAT. You should show the bottom-up tabular computation.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 動態規劃遞推公式的正確描述與解釋 (4 分)  \n  - 完全得分：正確定義狀態 (如 DP[i][j])、說明如何確認字符匹配且索引不重疊（i ≠ j），以及遞推公式的更新條件。  \n  - 部分得分：遞推公式描述不夠完整或缺少防止重疊的條件，但能表達出部分正確思路。  \n  - 無得分：未描述遞推公式或描述完全錯誤。\n\n- 自底向上表格計算的正確展示 (3 分)  \n  - 完全得分：依據字串 ATTAATAT 完整填寫 DP 表格，每步計算清楚明確，最終結果正確。  \n  - 部分得分：表格計算過程有部分錯誤或缺失，但能看出理解底層計算的基本流程。  \n  - 無得分：未展示底層表格計算過程或計算結果明顯錯誤。\n\n- 解題思路與推導過程的清晰論述 (3 分)  \n  - 完全得分：全面解釋解題思路、遞推關係的由來以及如何從表格中讀出最終答案，邏輯嚴謹。  \n  - 部分得分：論述過程有邏輯但不夠完整或詳盡，未涵蓋所有關鍵步驟。  \n  - 無得分：解題思路混亂或完全缺失推導過程。"
  },
  "6c": {
    "text": "Compute the Longest Palindrome Subsequence (LPS) in any sequence using dynamic programming. Given a string “character,” the LPS is “carac.” You should write down the recurrence and bottom-up tabular computation.",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 正確且完整地描述遞迴關係 (4 分)  \n  - 全額：正確說明基本情況 (base case) 與遞迴公式（例如：若 s[i] = s[j] 則 dp[i][j] = dp[i+1][j-1] + 2，否則 dp[i][j] = max(dp[i+1][j], dp[i][j-1]）  \n  - 部分：遞迴關係描述部分正確，但缺少關鍵細節或表達不夠清楚  \n  - 未作答：未提供遞迴關係或完全錯誤\n\n- 清楚詳盡地展示底向上表格計算步驟 (3 分)  \n  - 全額：完整說明如何初始化 DP 表格，如何依序填表，並以示例展示計算過程  \n  - 部分：對表格填寫與初始化有部分解釋，但步驟描述不完整或存在概念混淆  \n  - 未作答：未提供底向上表格計算或解釋過程不具參考性\n\n- 結果正確及解題邏輯條理分明 (3 分)  \n  - 全額：最終答案正確（例如對 \"character\" 得到 \"carac\"），並具備邏輯清晰的解題說明  \n  - 部分：最終答案或說明部分正確，但過程中存在邏輯不連貫或關鍵細節缺失  \n  - 未作答：最終答案錯誤或解題說明混亂，無法展現正確思路"
  },
  "7": {
    "text": "Consider the knapsack problem of n items and W pack size. Suppose the pack/item sizes are very large and the item values are very small. Give a dynamic programming (recurrence) for solving this problem. Illustrate your tabular computation using the following example (W=350).\n[TABLE]",
    "tables": [
      "| Item | Weight | Value |\n|------|--------|-------|\n| 1    | 100    | 1     |\n| 2    | 150    | 2     |\n| 3    | 200    | 4     |\n| 4    | 300    | 5     |"
    ],
    "figures": [],
    "score": "10",
    "rubric": "- 動態規劃遞迴公式的正確性與完整性（4 分）\n  - 滿分：正確定義狀態（例如 dp[i][v] 表示考慮前 i 項以獲得價值 v 的最小重量或其他對應描述）、明確表示「不取物品」與「取物品」兩種選擇的遞迴轉移，並包含適當的初始條件。\n  - 部分：公式基本正確但缺少初始條件或部分細節，或對狀態定義不夠精確。\n  - 無分：遞迴公式錯誤、關鍵選擇未體現或無初始條件。\n\n- 表格計算示例的準確展示與步驟完整性（4 分）\n  - 滿分：根據例子（W=350）正確利用表格展示每一階段的計算過程，清楚標示每次選擇物品對狀態更新的影響，最終能正確推導出最優解。\n  - 部分：表格展示部分計算步驟或中間結果正確，但關鍵步驟遺漏或細節不夠完整。\n  - 無分：表格計算展示錯誤、過程混亂或與題目要求不符。\n\n- 解題思路與說明的清晰性（2 分）\n  - 滿分：能夠清楚闡述選擇此動態規劃方法的原因，包括因物品尺寸大、價值小而採用以價值為狀態參數（或其他合理轉換）的策略，以及每步選擇的邏輯和意義。\n  - 部分：能大致描述思路，但論述不夠精確或缺乏關鍵動機說明。\n  - 無分：無法正確表達解題思路或解釋不清。"
  },
  "8": {
    "text": "Consider the following six activities with (start time, finish time, and value): (2, 4, 3), (5, 5, 5), (3, 4, 2), (1, 4, 3), (1, 3, 1), (3, 5, 4). Illustrate a dynamic programming algorithm for computing the mutually-exclusive subset of activities of maximum total values using the above example.\n```",
    "tables": [],
    "figures": [],
    "score": "10",
    "rubric": "- 活動排序與前驅活動的識別 (3 分)  \n  - 完全正確：正確將活動按照結束時間排序，並清楚定義/計算每個活動的前驅活動（即該活動之前不重疊的最後一個活動）；說明如何計算前驅索引。  \n  - 部分正確：排序或前驅活動的選擇部分符合要求，但有輕微錯誤或解釋不夠清楚。  \n  - 未達標：未進行排序或無法正確識別前驅活動。\n\n- 定義遞迴關係與動態規劃表格填充 (4 分)  \n  - 完全正確：正確定義動態規劃的遞迴公式（例如 OPT(j) = max( value[j] + OPT(p(j)), OPT(j-1) )），並具體說明如何利用該公式填充表格；解釋狀態轉移的過程並展示計算步驟。  \n  - 部分正確：遞迴公式定義基本正確，但在表格填充或狀態解釋上存在部分疏漏或模糊。  \n  - 未達標：遞迴公式定義錯誤，或無法正確演示表格填充過程。\n\n- 舉例說明與構造最終解 (3 分)  \n  - 完全正確：使用題中範例清楚說明如何利用動態規劃表格進行回溯，選取互斥活動，構造出最大總價值活動組合，並展示最終值及活動選取過程。  \n  - 部分正確：有嘗試利用範例解釋，但在回溯過程或具體活動選取上說明不足。  \n  - 未達標：未針對範例進行具體說明或回溯解構造過程不清晰。"
  }
}